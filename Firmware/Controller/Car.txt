#include <Arduino.h>
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>
#include <stdio.h>
#include <printf.h>
#include <RF24_config.h>
#include <Servo.h>
using namespace std;

#define MessageID 45949




const int ServoPins[3] = {2,3,4};
//       Servos    1 2 3
const int ServoOffsets[3] = {0, 120, 240};

const uint8_t L_EN[3] = {30,32,34};
const uint8_t L_PWM[3] = {40,42,44};
const uint8_t R_EN[3] = {31,33,35};
const uint8_t R_PWM[3] = {41,43,45};

int MotorSpeeds[3] = {0,0,0};
int ServoPositions[3] = {0, 0, 0};
Servo ServoObjects[3];


// Still need to do motor stuff



// This is how data is recieved from the controller
typedef struct{
  int16_t Identifier;
  float LeftJoyForce; // How far from center the joystick is
  float LeftJoyOrient; // The angle relative to the centre of the joystick
  float RightJoyForce;
  float RightJoyOrient;
}__attribute__((packed)) DataStruct;
DataStruct dataPackage;

// Define functions
void getModuleCrab(int (&Mos)[3], int (&Svp)[3]);








// Define radio
RF24 radio(48,49); // CE, CSN
const byte address[5] = "0110";



void setup() {
  printf_begin();
  pinMode(48,  OUTPUT); 
  pinMode(49, OUTPUT);


  // attach servos to pins
  for (int i; i < 3; i++){
    ServoObjects[i].attach(ServoPins[i]);
    pinMode(L_EN[i],  OUTPUT); 
    pinMode(R_EN[i],  OUTPUT); 
    pinMode(L_PWM[i],  OUTPUT); 
    pinMode(R_PWM[i],  OUTPUT);
  }

  // end pinmodes

  Serial.begin(9600); 
  if (!radio.begin()) { Serial.println(F("radio hardware not responding!"));}
  radio.openReadingPipe(0, address);
  radio.setPALevel(-18);
  radio.startListening();

  // Make an LED or something to check if Radio is transmitting
}






void loop() {
  while (!radio.available()); // If the radio drops out repeatedly i'll add the code for a restart then
  radio.read( &dataPackage, sizeof(DataStruct) );

  if (dataPackage.Identifier != MessageID){ // If unauthorized message
    return;
  };

  if (dataPackage.RightJoyForce == 0){ // if not turning, I want the simpler crab drive math to work
    getModuleCrab(MotorSpeeds, ServoPositions);
  } else {
    // I want it to reset until I get snake working
    // Once the complicated snake math is working, it goes here
    getModuleDefaults(MotorSpeeds, ServoPositions);
  }

  //I will need to figure out how to get the servo positioning to work
  for (int i = 0; i < 3; i++){
    
    int rotation = ServoPositions[i] - ServoOffsets[i];
    int rotation = rotation % 360;
    
    if (rotation < 180){
      analogWrite(L_PWM[i], 0);
      digitalWrite(L_EN[i], LOW);
      digitalWrite(R_EN[i], HIGH);
      analogWrite(R_PWM[i], MotorSpeeds[i]);
      ServoObjects[i].write(rotation);


    } else {
      analogWrite(R_PWM[i], 0);
      digitalWrite(R_EN[i], LOW);
      analogWrite(L_PWM[i], MotorSpeeds[i]);
      digitalWrite(L_EN[i], HIGH);
      ServoObjects[i].write(rotation - 180);
    }
  }
  
}








void getModuleCrab(int (&Mos)[3], int(&Svp)[3]) {
   // crab drive math; point and go
  for (int i = 0; i<3; i++){
    Mos[i] = round(dataPackage.LeftJoyForce); // still on the 512 scale
    Svp[i] = round(dataPackage.LeftJoyOrient* (180.0 / PI));
  }
}






void getModuleDefaults(int (&Mos)[3], int(&Svp)[3]) {
  // Resets motor speeds and all to defaults
  for (int i = 0; i<3; i++){
    Mos[i] = 0;
    Svp[i] = ServoOffsets[i];
  }
}